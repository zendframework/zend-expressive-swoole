{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-swoole Repository abandoned 2019-12-31 This repository has moved to mezzio/mezzio-swoole . This library provides the support of Swoole into an Expressive application. This means you can execute your Expressive application using Swoole directly from the command line. Installation Run the following to install this library: $ composer require zendframework/zend-expressive-swoole Configuration After installing zend-expressive-swoole, you will need to first enable the component, and then optionally configure it. We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents: <?php use Zend\\Expressive\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), []); The above will setup the Swoole integration for your application. By default, Swoole executes the HTTP server with host 127.0.0.1 on port 8080 . You can change these values via configuration. Assuming you have the above, modify it to read as follows: <?php use Zend\\Expressive\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => 'insert hostname to use here', 'port' => 80, // use an integer value here ], ], ]); Expressive skeleton 3.1.0 and later If you have built your application on the 3.1.0 or later version of the Expressive skeleton, you do not need to instantiate and invoke the package's ConfigProvider , as the skeleton supports it out of the box. You will only need to provide any additional configuration of the HTTP server. Execute Once you have performed the configuration steps as outlined above, you can run an Expressive application with Swoole using the following command: $ ./vendor/bin/zend-expressive-swoole start Call the command without arguments to get a list of available commands, and use the help meta-argument to get help on individual commands: $ ./vendor/bin/zend-expressive-swoole help start Documentation Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/ Support Issues Chat Forum","title":"Home"},{"location":"#zend-expressive-swoole","text":"","title":"zend-expressive-swoole"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to mezzio/mezzio-swoole . This library provides the support of Swoole into an Expressive application. This means you can execute your Expressive application using Swoole directly from the command line.","title":"Repository abandoned 2019-12-31"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-swoole","title":"Installation"},{"location":"#configuration","text":"After installing zend-expressive-swoole, you will need to first enable the component, and then optionally configure it. We recommend adding a new configuration file to your autoload directory, config/autoload/swoole.local.php . To begin with, use the following contents: <?php use Zend\\Expressive\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), []); The above will setup the Swoole integration for your application. By default, Swoole executes the HTTP server with host 127.0.0.1 on port 8080 . You can change these values via configuration. Assuming you have the above, modify it to read as follows: <?php use Zend\\Expressive\\Swoole\\ConfigProvider; return array_merge((new ConfigProvider())(), [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => 'insert hostname to use here', 'port' => 80, // use an integer value here ], ], ]);","title":"Configuration"},{"location":"#execute","text":"Once you have performed the configuration steps as outlined above, you can run an Expressive application with Swoole using the following command: $ ./vendor/bin/zend-expressive-swoole start Call the command without arguments to get a list of available commands, and use the help meta-argument to get help on individual commands: $ ./vendor/bin/zend-expressive-swoole help start","title":"Execute"},{"location":"#documentation","text":"Browse the documentation online at https://docs.zendframework.com/zend-expressive-swoole/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"how_it_works/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-swoole/v1/how-it-works/'; });","title":"_how-it-works"},{"location":"intro/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-swoole/v1/intro/'; });","title":"_introduction"},{"location":"logging/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-swoole/v1/logging/'; });","title":"_logging"},{"location":"static-resources/","text":"document.addEventListener(\"DOMContentLoaded\", function (event) { window.location.pathname = '/zend-expressive-swoole/v1/static-resources/'; });","title":"_static-resources"},{"location":"v1/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. > For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. zend-expressive-session-cache zend-expressive-session-cache provides a persistence adapter for zend-expressive-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: zend-expressive-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests \u2014 when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this->proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this->proxy->someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' => [ 'factories' => [ OriginalImplementation::class => OriginalImplementationFactory::class, OriginalInterface::class => ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this->renderer->render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this->rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this->rendererFactory)(); return new HtmlResponse($renderer->render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the zend-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; use Zend\\Expressive\\ZendView\\ZendViewRendererFactory; class ZendViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new ZendViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container->get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: $$$$FENCED_CODE_BLOCK_5e3085c7d70db8.50758908 Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $$$$FENCED_CODE_BLOCK_5e3085c7d71124.62208987 This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v1/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v1/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v1/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v1/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: zend-expressive-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests \u2014 when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v1/how-it-works/","text":"How it works When you run an Expressive application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in zend-expressive-swoole is a runner that enables the execution of an Expressive application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation looks similar to the following: public function run() : void { $this->swooleHttpServer->on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port); }); $this->swooleHttpServer->on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request->server['remote_addr'], $request->server['request_method'], $request->server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this->serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this->emitMarshalServerRequestException($emitter, $e); return; } $emitter->emit($this->handler->handle($psr7Request)); }); $this->swooleHttpServer->start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by zend-diactoros ) via the class Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Zend\\Expressive\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Expressive application using zend-expressive-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The ZF developers performed a benchmark running the default zend-expressive-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Expressive with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.swoole-http-server.options.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v1/how-it-works/#how-it-works","text":"When you run an Expressive application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in zend-expressive-swoole is a runner that enables the execution of an Expressive application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation looks similar to the following: public function run() : void { $this->swooleHttpServer->on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port); }); $this->swooleHttpServer->on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request->server['remote_addr'], $request->server['request_method'], $request->server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this->serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this->emitMarshalServerRequestException($emitter, $e); return; } $emitter->emit($this->handler->handle($psr7Request)); }); $this->swooleHttpServer->start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by zend-diactoros ) via the class Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Zend\\Expressive\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Expressive application using zend-expressive-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v1/how-it-works/#performance","text":"The ZF developers performed a benchmark running the default zend-expressive-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Expressive with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.swoole-http-server.options.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v1/intro/","text":"Swoole Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL . Install zend-expressive-swoole To install this package, use Composer : $ composer require zendframework/zend-expressive-swoole Swoole with Expressive zend-expressive-swoole enables an Expressive application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ php public/index.php This command will execute Swoole on localhost via port 8080 . Expressive skeleton versions prior to 3.1.0 The above will work immediately after installing zend-expressive-swoole if you are using a version of zend-expressive-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/zend-expressive-swoole.global.php or config/autoload/zend-expressive-swoole.local.php with the following contents: $$$$FENCED_CODE_BLOCK_5e3085c7d7ac62.30000990 You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => '192.168.0.1', 'port' => 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => '192.168.0.1', 'port' => 9501, 'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' => [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' => 'path/to/ssl.crt', 'ssl_key_file' => 'path/to/ssl.key', // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' => true, ], ], ], ]; Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Intro"},{"location":"v1/intro/#swoole","text":"Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v1/intro/#install-swoole","text":"You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v1/intro/#install-zend-expressive-swoole","text":"To install this package, use Composer : $ composer require zendframework/zend-expressive-swoole","title":"Install zend-expressive-swoole"},{"location":"v1/intro/#swoole-with-expressive","text":"zend-expressive-swoole enables an Expressive application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ php public/index.php This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Expressive"},{"location":"v1/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Zend\\Expressive\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %>s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %>s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -> %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t \u201c%r\u201d %>s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // <-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, you can create your own factory that produces an AccessLogInterface instance, and map it to the service. This is the best route if you want to write your own implementation, or want to use a different PSR-3 logger service. If you are okay with re-using your existing PSR-3 logger, the provided Zend\\Expressive\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. The factory will also look at the following configuration values: 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'logger' => [ 'format' => string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' => bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger->pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger->pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v1/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v1/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Zend\\Expressive\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v1/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v1/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. zend-expressive-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Zend\\Expressive\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ // Document root; defaults to \"getcwd() . '/public'\" 'document-root' => '/path/to/static/files/to/serve', // Extension => content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' => [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' => 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' => 'weak|strong', // gzip options 'gzip' => [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' => 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' => [ 'regex' => [ 'cache-control' => [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' => bool, // Emit a Last-Modified header? 'etag' => bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ 'document-root' => '/var/www/htdocs', 'type-map' => [ 'css' => 'text/css', 'gif' => 'image/gif', 'ico' => 'image/x-icon', 'jpg' => 'image/jpg', 'jpeg' => 'image/jpg', 'js' => 'application/javascript', 'png' => 'image/png', 'svg' => 'image/svg+xml', 'txt' => 'text/plain', ], 'clearstatcache-interval' => 7200, 'etag-type' => 'strong', 'gzip' => [ 'level' => 3, ], 'directives' => [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [ 'cache-control' => [ 'public', 'no-transform', ], 'last-modified' => true, 'etag' => true, ], '/\\.txt$/' => [ 'cache-control' => [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Zend\\Expressive\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Static Resources"},{"location":"v1/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. zend-expressive-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Zend\\Expressive\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it.","title":"Static Resources"},{"location":"v1/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v1/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ // Document root; defaults to \"getcwd() . '/public'\" 'document-root' => '/path/to/static/files/to/serve', // Extension => content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' => [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' => 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' => 'weak|strong', // gzip options 'gzip' => [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' => 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' => [ 'regex' => [ 'cache-control' => [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' => bool, // Emit a Last-Modified header? 'etag' => bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v1/static-resources/#writing-middleware","text":"Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v1/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Zend\\Expressive\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v2/async-tasks/","text":"Triggering Async Tasks Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes \u2014 allowing your application to continue responding to requests while the server processes your task. Configuring the Server Process In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they triggered, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute one after the other. 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => '127.0.0.1', 'port' => 8080, 'options' => [ 'worker_num' => 4, // The number of HTTP Server Workers 'task_worker_num' => 4, // The number of Task Workers ], ], ]; No CLI option for task_worker_num Unlike worker_num , there is no CLI option for task_worker_num . This is because enabling the task worker also requires registering a task worker with the server. To prevent accidental startup failures due to passing an option to specify the number of task workers without having registered a task worker, we omitted the CLI option. Task Event Handlers When task workers are enabled, the Swoole server will now require that you register two event callbacks with the server; without them, the server will refuse to start. The two events are: task , which will define the code for handling tasks. finish , which will execute when a task has completed. Registering the Handlers The signature for the task event handler is: function ( \\Swoole\\Http\\Server $server, int $taskId, int $sourceWorkerId, $dataForWorker ) : void where: $server is the main HTTP server process $taskId is a number that increments each time the server triggers a new task. $sourceWorkerId is an integer that defines the worker process that is executing the workload. $dataForWorker contains the value passed to the $server->task() method when initially triggering the task. This value can be any PHP value, with the exception of a resource . To register the handler with the server, you must call it's on() method, before the server has been started: $server->on('task', $callable); As previously mentioned, you must also register an event handler for the finish event. This callback for this event should have the following signature: function ( \\Swoole\\Http\\Server $server, int $taskId, $userData ) : void The first two parameters are identical to the task event handler. The $userData parameter will contain the return value of the task event handler. Registering your callable for the finish event is accomplished like this: $server->on('finish', $callable); There can be only one There can be only one event handler per event type. Subsequent calls to on('<EventName>') replace the previously registered callable. Finishing a task If you do not return anything from your task event handler, the finish handler will not be called . The Swoole documentation recommends that the task worker callback manually finish the task in these situations: $$$$FENCED_CODE_BLOCK_5e3085c7d8ee78.74212581 Even if you do not call the above method, the handler must be defined, or the server will refuse to start. An example task worker The following example code illustrates a task worker with logging capabilities that uses a message notifier to process data: // In src/App/TaskWorker.php: namespace App; use Psr\\EventDispatcher\\MessageInterface; use Psr\\EventDispatcher\\MessageNotifierInterface; use Psr\\Log\\LoggerInterface; use Throwable; class TaskWorker { private $notifier; private $logger; public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier) { $this->logger = $logger; $this->notifier = $notifier; } public function __invoke($server, $taskId, $fromId, $data) { if (! $data instanceof MessageInterface) { $this->logger->error('Invalid data type provided to task worker: {type}', [ 'type' => is_object($data) ? get_class($data) : gettype($data) ]); return; } $this->logger->notice('Starting work on task {taskId} using data: {data}', [ 'taskId' => $taskId, 'data' => json_encode($data), ]); try { $this->notifier->notify($data); } catch (Throwable $e) { $this->logger->error('Error processing task {taskId}: {error}', [ 'taskId' => $taskId, 'error' => $e->getTraceAsString(), ]); } // Notify the server that processing of the task has finished: $server->finish(''); } } This invokable class needs to be attached to the $server->on('task') event before the server has started. The easiest place to accomplish this is in a delegator factory targeting the Swoole HTTP server. First, we'll create the delegator factory: // In src/App/TaskWorkerDelegator.php: namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Server as HttpServer; class TaskWorkerDelegator { public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer { $server = $callback(); $logger = $container->get(LoggerInterface::class); $server->on('task', $container->get(TaskWorker::class)); $server->on('finish', function ($server, $taskId, $data) use ($logger) { $logger->notice('Task #{taskId} has finished processing', ['taskId' => $taskId]); }); return $server; } } Next, we'll register it with our container: // In config/autoload/dependencies.php: return [ 'dependencies' => [ 'delegators' => [ \\Swoole\\Http\\Server::class => [ \\App\\TaskWorkerDelegator::class, ], ], ], ]; With this in place, we can now trigger tasks within our application. In the scenario outlined above, the task worker expects messages ; it then notifies listeners of that message so they may respond to it. Triggering Tasks in Middleware Considering that this library provides an application runner for middleware applications, you will likely trigger tasks from within your middleware or request handlers. In each case, you will need to compose the Swoole HTTP server instance as a class dependency, as tasks are triggered via the server via its task() method. The method can accept any value except a resource as an argument. In the example below, ContactMessage will implement the MessageInterface from the above example. The request handler uses values from the request to create the ContactMessage instance, and then create a task from it. It then immediately returns a response. // in src/App/Handler/TaskTriggeringHandler.php: namespace App\\Handler; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TaskTriggeringHandler implements RequestHandlerInterface { private $responseFactory; private $server; private $template; public function __construct( HttpServer $server, TemplateRendererInterface $template, ResponseFactoryInterface $responseFactory ) { $this->server = $server; $this->template = $template; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request->getParsedBody(); // A fictonal event describing a contact request: $event = new ContactEvent([ 'to' => $data['email'], 'subject' => $data['subject'], 'message' => $data['message'], ]); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this->server->task($event); // The task() method is asynchronous, so execution continues immediately. $response = ($this->responseFactory()->createResponse()) ->withHeader('Content-Type', 'text/html'); $response->getBody()->write($this->template->render('contact::thank-you', []); return $response; } }","title":"Async Tasks"},{"location":"v2/async-tasks/#triggering-async-tasks","text":"Application resources requiring lengthy processing are not uncommon. In order to prevent these processes from impacting user experience, particularly when the user does not need to wait for the process to complete, we often delegate these to a message queue . While message queues are powerful, they also require additional infrastructure for your application, and can be hard to justify when you have a small number of heavy processes, or a small number of users. In order to facilitate async processing, Swoole servers provides task worker processes, allowing your application to trigger tasks without the need for an external message queue, and without impacting the server worker processes \u2014 allowing your application to continue responding to requests while the server processes your task.","title":"Triggering Async Tasks"},{"location":"v2/async-tasks/#configuring-the-server-process","text":"In order to take advantage of this feature, you will first need to configure the server to start up task workers. In your local configuration for the server, you'll need to add task_worker_num . The number of workers you configure define the number of concurrent tasks that can be executed at once. Tasks are queued in the order that they triggered, meaning that a task_worker_num of 1 will offer no concurrency and tasks will execute one after the other. 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => '127.0.0.1', 'port' => 8080, 'options' => [ 'worker_num' => 4, // The number of HTTP Server Workers 'task_worker_num' => 4, // The number of Task Workers ], ], ];","title":"Configuring the Server Process"},{"location":"v2/async-tasks/#task-event-handlers","text":"When task workers are enabled, the Swoole server will now require that you register two event callbacks with the server; without them, the server will refuse to start. The two events are: task , which will define the code for handling tasks. finish , which will execute when a task has completed.","title":"Task Event Handlers"},{"location":"v2/async-tasks/#an-example-task-worker","text":"The following example code illustrates a task worker with logging capabilities that uses a message notifier to process data: // In src/App/TaskWorker.php: namespace App; use Psr\\EventDispatcher\\MessageInterface; use Psr\\EventDispatcher\\MessageNotifierInterface; use Psr\\Log\\LoggerInterface; use Throwable; class TaskWorker { private $notifier; private $logger; public function __construct(LoggerInterface $logger, MessageNotifierInterface $notifier) { $this->logger = $logger; $this->notifier = $notifier; } public function __invoke($server, $taskId, $fromId, $data) { if (! $data instanceof MessageInterface) { $this->logger->error('Invalid data type provided to task worker: {type}', [ 'type' => is_object($data) ? get_class($data) : gettype($data) ]); return; } $this->logger->notice('Starting work on task {taskId} using data: {data}', [ 'taskId' => $taskId, 'data' => json_encode($data), ]); try { $this->notifier->notify($data); } catch (Throwable $e) { $this->logger->error('Error processing task {taskId}: {error}', [ 'taskId' => $taskId, 'error' => $e->getTraceAsString(), ]); } // Notify the server that processing of the task has finished: $server->finish(''); } } This invokable class needs to be attached to the $server->on('task') event before the server has started. The easiest place to accomplish this is in a delegator factory targeting the Swoole HTTP server. First, we'll create the delegator factory: // In src/App/TaskWorkerDelegator.php: namespace App; use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Server as HttpServer; class TaskWorkerDelegator { public function __invoke(ContainerInterface $container, $serviceName, callable $callback) : HttpServer { $server = $callback(); $logger = $container->get(LoggerInterface::class); $server->on('task', $container->get(TaskWorker::class)); $server->on('finish', function ($server, $taskId, $data) use ($logger) { $logger->notice('Task #{taskId} has finished processing', ['taskId' => $taskId]); }); return $server; } } Next, we'll register it with our container: // In config/autoload/dependencies.php: return [ 'dependencies' => [ 'delegators' => [ \\Swoole\\Http\\Server::class => [ \\App\\TaskWorkerDelegator::class, ], ], ], ]; With this in place, we can now trigger tasks within our application. In the scenario outlined above, the task worker expects messages ; it then notifies listeners of that message so they may respond to it.","title":"An example task worker"},{"location":"v2/async-tasks/#triggering-tasks-in-middleware","text":"Considering that this library provides an application runner for middleware applications, you will likely trigger tasks from within your middleware or request handlers. In each case, you will need to compose the Swoole HTTP server instance as a class dependency, as tasks are triggered via the server via its task() method. The method can accept any value except a resource as an argument. In the example below, ContactMessage will implement the MessageInterface from the above example. The request handler uses values from the request to create the ContactMessage instance, and then create a task from it. It then immediately returns a response. // in src/App/Handler/TaskTriggeringHandler.php: namespace App\\Handler; use Psr\\Http\\Message\\ResponseFactoryInterface; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Swoole\\Http\\Server as HttpServer; use Zend\\Expressive\\Template\\TemplateRendererInterface; class TaskTriggeringHandler implements RequestHandlerInterface { private $responseFactory; private $server; private $template; public function __construct( HttpServer $server, TemplateRendererInterface $template, ResponseFactoryInterface $responseFactory ) { $this->server = $server; $this->template = $template; $this->responseFactory = $responseFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { // Gather data from request $data = $request->getParsedBody(); // A fictonal event describing a contact request: $event = new ContactEvent([ 'to' => $data['email'], 'subject' => $data['subject'], 'message' => $data['message'], ]); // task() returns a task identifier, if you want to use it; otherwise, // you can ignore the return value. $taskIdentifier = $this->server->task($event); // The task() method is asynchronous, so execution continues immediately. $response = ($this->responseFactory()->createResponse()) ->withHeader('Content-Type', 'text/html'); $response->getBody()->write($this->template->render('contact::thank-you', []); return $response; } }","title":"Triggering Tasks in Middleware"},{"location":"v2/command-line/","text":"Command Line Tooling This package ships the vendor binary zend-expressive-swoole . It provides the following commands: start to start the server stop to stop the server (when run in daemonized mode) reload to reload the server (when run in daemonized mode) status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/zend-expressive-swoole help start The stop , status , and reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The start command, however, may need customizations if you have customized your application bootstrap. The start command The start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Zend\\Expressive\\Application and Zend\\Expressive\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Expressive skeleton application. Writing a custom start command If your application needs alternate bootstrapping (e.g., if you have modified the public/index.php , or if you are using this package with a different middleware runtime), we recommend writing a custom start command. As an example, let's say you have altered your application such that you're defining your routes in multiple files, and instead of: (require 'config/routes.php')($app, $factory, $container); you instead have something like: $handle = opendir('config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } You could write a command such as the following: // In src/App/Command/StartCommand.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; use Swoole\\Http\\Server as SwooleHttpServer; use Symfony\\Component\\Console\\Input\\InputInterface; use Symfony\\Component\\Console\\Output\\OutputInterface; use Zend\\Expressive\\Application; use Zend\\Expressive\\MiddlewareFactory; use Zend\\Expressive\\Swoole\\Command\\StartCommand as BaseStartCommand; use Zend\\Expressive\\Swoole\\PidManager; class StartCommand extends BaseStartCommand { protected function execute(InputInterface $input, OutputInterface $output) : int { // This functionality is identical to the base start command, and should // be copy and pasted to your implementation: $this->pidManager = $this->container->get(PidManager::class); if ($this->isRunning()) { $output->writeln('<error>Server is already running!</error>'); return 1; } $server = $this->container->get(SwooleHttpServer::class); $server->set([ 'daemonize' => $input->getOption('daemonize'), 'worker_num' => $input->getOption('num-workers') ?? self::DEFAULT_NUM_WORKERS, ]); /** @var \\Zend\\Expressive\\Application $app */ $app = $this->container->get(Application::class); /** @var \\Zend\\Expressive\\MiddlewareFactory $factory */ $factory = $this->container->get(MiddlewareFactory::class); // Execute programmatic/declarative middleware pipeline and routing // configuration statements (require 'config/pipeline.php')($app, $factory, $this->container); // // This is the new code from above: // $handle = opendir(getcwd() . '/config/routes/'); while (false !== ($entry = readdir($handle))) { if (false === strrpos($entry, '.php')) { continue; } (require $entry)($app, $factory, $container); } // And now we return to the original code: // Run the application $app->run(); return 0; } } You will also need to write a factory for the class: // In src/App/Command/StartCommandFactory.php: namespace App\\Command; use Psr\\Container\\ContainerInterface; class StartCommandFactory { public function __invoke(ContainerInterface $container) : StartCommand { return new StartCommand($container); } } If this is all you're changing, you can map this new command to the existing Zend\\Expressive\\Swoole\\Command\\StartCommand service within your configuration: // in config/autoload/dependencies.global.php: use App\\Command\\StartCommandFactory; use Zend\\Expressive\\Swoole\\Command\\StartCommand; return [ 'dependencies' => [ 'factories' => [ StartCommand::class => StartCommandFactory::class, ], ], ]; Since the zend-expressive-swoole binary uses your application configuration and container, this will substitute your command for the shipped command!","title":"Command Line Tooling"},{"location":"v2/command-line/#command-line-tooling","text":"This package ships the vendor binary zend-expressive-swoole . It provides the following commands: start to start the server stop to stop the server (when run in daemonized mode) reload to reload the server (when run in daemonized mode) status to determine the server status (running or not running) You may obtain help for each command using the help meta-command: $ ./vendor/bin/zend-expressive-swoole help start The stop , status , and reload commands are sufficiently generic to work regardless of runtime or application, as they work directly with the Swoole process manager. The start command, however, may need customizations if you have customized your application bootstrap.","title":"Command Line Tooling"},{"location":"v2/command-line/#the-start-command","text":"The start command will start the web server using the following steps: It pulls the Swoole\\Http\\Server service from the application dependency injection container, and calls set() on it with options denoting the number of workers to run (provided via the --num-workers or -w option), and whether or not to daemonize the server (provided via the --daemonize or -d option). It pulls the Zend\\Expressive\\Application and Zend\\Expressive\\MiddlewareFactory services from the container. It loads the config/pipeline.php and config/routes.php files, invoking their return values with the application, middleware factory, and dependency injection container instances. It calls the run() method of the application instance. These are roughly the steps taken within the application bootstrap ( public/index.php ) of the Expressive skeleton application.","title":"The start command"},{"location":"v2/considerations/","text":"Considerations when using Swoole Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application. Long-running processes When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead. PDO Coroutine Support Please be aware that enabling coroutine support with Swoole\\Runtime::enableCoroutine() only decorates MySql PDO connections with coroutines; other drivers (e.g., pdo_pgsql) remain blocking as of Swoole 4.1.2. For more details, visit the related bug report on the Swoole issue tracker . Sessions Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives. zend-expressive-session-cache zend-expressive-session-cache provides a persistence adapter for zend-expressive-session that uses a PSR-6 CacheItemPoolInterface implementation for storing and retrieving sessions. This approach requires that you setup a backend cache storage for your session data. psr7-sessions/storageless PSR7Session provides session middleware that uses JWT tokens within the session cookie to transmit session data between the server and client. This approach requires no central session storage, but does impose limits on the amount of information you can store in a session. Stateless services The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: zend-expressive-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests \u2014 when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail. Decoration If a service implements an interface, you can decorate the service to make it stateless. Well-written interfaces will be stateless by design, and not provide methods meant to internally change state. In these situations, you can create a proxy class that decorates the original service: class ProxyService implements OriginalInterface { /** @var OriginalInterface */ private $proxy; public function __construct(OriginalInterface $proxy) { $this->proxy = $proxy; } public function someMethodDefinedInInterface(string $argument) : Result { return $this->proxy->someMethodDefinedInInterface($argument); } } You would then: Map the factory for the original service to the implementation name. Create a factory that consumes the original service, and produces the proxy. Map the interface name to the factory that creates the proxy. // in config/autoload/dependencies.global.php: return [ 'dependencies' => [ 'factories' => [ OriginalImplementation::class => OriginalImplementationFactory::class, OriginalInterface::class => ProxyServiceFactory::class, ], ], ]; If you were writing to the interface, and not the implementation, you can now guarantee that any non-interface methods that changed state can now no longer be called. If the interface itself defines methods that modify state, we recommend writing a proxy that implements those methods as no-ops and/or that raises exceptions when those methods are invoked. (The latter approach ensures that you discover quickly when code is exercising those methods.) In each case, you would then use a delegator factory , to decorate the original instance in the proxy class: function (ContainerInterface $container, string $name, callable $callback) { return new ProxyService($callback()); } (You can also use the delegator factory approach with the previous proxy service example.) Extension When a service does not implement an interface, but exposes methods that change internal state, you can extend the original class to make the methods that change state into no-ops, or have them raise exceptions. (The latter approach ensures that you discover quickly when code is exercising those methods.) As an example, let's say you have a class DataMapper that defines a method setTable() in it, and that method would change the database table the mapper would query. This is a potentially bad situation! We could extend the class as follows: class StatelessDataMapper extends DataMapper { public function setTable(string $table) : void { throw new \\DomainException(sprintf( '%s should not be called in production code!', __METHOD__ )); } } In your factory that creates an instance of DataMapper , have it instead return a StatelessDataMapper instance, and you're now safe. Factories Another approach is to modify your consuming code to accept a factory that will produce the service you'll consume, instead of the service itself. This approach ensures that the service is created only when needed, mitigating any state change issues. As an example, consider the following middleware that currently consumes a template renderer: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var TemplateRendererInterface */ private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function handle(ServerRequestInterface $request) : ResponseInterface { return new HtmlResponse($this->renderer->render( 'app::some-handler', [] )); } } What we will do is modify it to accept a callable to the constructor. We will then call that factory just before we need the renderer; we will not store the result in the handler, as we want to ensure we have a new instance each time. use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Template\\TemplateRendererInterface; class SomeHandler implements RequestHandlerInterface { /** @var callable */ private $rendererFactory; public function __construct(callable $rendererFactory) { $this->rendererFactory = $rendererFactory; } public function handle(ServerRequestInterface $request) : ResponseInterface { /** @var TemplateRendererInterface $renderer */ $renderer = ($this->rendererFactory)(); return new HtmlResponse($renderer->render( 'app::some-handler', [] )); } } From here, we create a factory for our dependency injection container that will return the factory we use here. As an example, if we are using the zend-view integration , we might do the following: use Psr\\Container\\ContainerInterface; use Zend\\Expressive\\Template\\TemplateRendererInterface; use Zend\\Expressive\\ZendView\\ZendViewRendererFactory; class ZendViewRendererFactoryFactory { public function __invoke(ContainerInterface $container) : callable { $factory = new ZendViewRendererFactory(); return function () use ($container, $factory) : TemplateRendererInterface { return $factory($container); }; } } If we mapped this to the \"service\" Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory , our factory for the SomeHandler class would then look like: use Zend\\Expressive\\Template\\TemplateRendererInterfaceFactory; function (ContainerInterface $container) : SomeHandler { return new SomeHandler( $container->get(TemplateRendererInterfaceFactory::class) ); } This approach ensures we get a new instance with known state at precisely the moment we wish to execute the functionality. By ensuring we do not store the instance in any way, we also ensure it is garbage collected when the instance goes out of scope (i.e., when the method ends). Handling the template data problem If we want our services to be stateless, how do we handle problems such as the documented addDefaultParam() issue referenced earlier ? In this case, the original problem was \"how do we get common request data into templates?\" The solution originally provided was to alter the state of the template renderer. Another solution, however, is one we've also documented previously: use server attributes to pass data between middleware . In this particular case, the middleware documented in the original solution could be modified to provide data to a request attribute, instead of altering the state of the template renderer. It might then become: $$$$FENCED_CODE_BLOCK_5e3085c7d7efd4.24138208 Once that change is made, you would then change your handler to do the following: Pull that attribute, providing a default [] value. Merge the pulled value with any local values when rendering the template. For example: $$$$FENCED_CODE_BLOCK_5e3085c7d7f1a2.36924529 This approach, while it requires more work on the part of handler authors, ensures that the renderer state does not vary between requests, making it safer for usage with Swoole and other long-running processes.","title":"Considerations when using Swoole"},{"location":"v2/considerations/#considerations-when-using-swoole","text":"Because Swoole uses an event loop, and because it is able to load your application exactly once, you must take several precautions when using it to serve your application.","title":"Considerations when using Swoole"},{"location":"v2/considerations/#long-running-processes","text":"When using the Swoole HTTP server, your application runs within an event loop . One benefit of this is that you can then defer execution of code until the next tick of the loop. This can be used to delay long-running code from executing until after a response has been sent to the client, which can obviate the need for tools such as message queues. The problem, however, is that when a worker does begin to handle the deferred functionality, it will run as long as needed until the work is done. This then means that the worker is blocked from handling new requests until that work is done. If you have enough workers, or the number of such long-running processes if few and far-between, this may not be an issue for you. However, it is a commonly documented issue in other similar systems such as Node.js. The solution in these cases is the same as for general PHP applications: add a message queue to your systems infrastructure, and delegate such work to the message queue instead.","title":"Long-running processes"},{"location":"v2/considerations/#sessions","text":"Because Swoole runs as a PHP CLI application, it generally does not play well with the PHP Session extension. However, there are alternatives.","title":"Sessions"},{"location":"v2/considerations/#stateless-services","text":"The typical PHP model is that the engine is fired up, runs your code, and then tears down again, for every single request . As such, PHP is said to have a \"shared nothing architecture\". This is a tremendous boon to developers, as they can ignore things found in lower level languages, such as garbage cleanup, memory management, and more. This model also comes with a cost: every single request requires bootstrapping your application. Benchmarks we have performed show that bootstrapping is often the most expensive operation in applications, often accounting for 25-50% of total resource usage and execution time. One reason technologies such as Swoole can provide a performance boost is due to the fact that they can bootstrap your application exactly once, often during startup. This alone can account for the performance boost of many applications. However, it has a price: you now need to consider what changes may happen inside the various classes in your dependency injection container, and the impact those changes may have on later requests, or even other requests happening concurrently. As one example: zend-expressive-template provides an interface, TemplateRendererInterface , that allows you to render a template. That interface also allows you to provide template paths, and default parameters to pass to every template, and these methods are often invoked within factories or delegators in order to configure the renderer implementation. However, we have also documented using addDefaultParam() for passing values discovered in the request to later handlers . This practice accumulates state in the renderer that can cause problems later: Flash messages discovered in one request might then be pushed to templates renderered in subsequent requests \u2014 when they are no longer in scope. User details from one request might persist to a template rendered for an unauthenticated user in another request, exposing information. These are clearly problematic behaviors! As such, you must guard against state in services you provide in your dependency injection container, as any state changes have ramifications for other requests. Write services to be stateless, and/or mark state-changing methods as @internal to prevent users from calling them in non-bootstrap code. If the services are provided by a third party, you have a few options: Decorating an existing service that implements an interface to make it stateless. Extending a service to make state-changing methods no-ops. Injecting factories that produce the stateful services, instead of the service itself. We'll look at each in detail.","title":"Stateless services"},{"location":"v2/hot-code-reload/","text":"Hot Code Reload Since 2.3.0 To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production! Requirements ext-inotify This library ships with an inotify based implementation of Zend\\Expressive\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded. Configuration The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'hot-code-reload' => [ // Set to true to enable hot code reload; the default is false. 'enable' => true, // Time in milliseconds between checks to changes in files. 'interval' => 500, ], ], ]; Logging When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation. Limitations Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Hot Code Reloading"},{"location":"v2/hot-code-reload/#hot-code-reload","text":"Since 2.3.0 To ease development against a running Swoole HTTP server, hot code reloading can be enabled. With this feature enabled, a Swoole worker will monitor included PHP files using inotify , and will restart all workers if a file is changed, thus mitigating the need to manually restart the server to test changes. This feature should only be used in your local development environment, and should not be used in production!","title":"Hot Code Reload"},{"location":"v2/hot-code-reload/#requirements","text":"ext-inotify This library ships with an inotify based implementation of Zend\\Expressive\\Swoole\\HotCodeReload\\FileWatcherInterface . In order to use it, the inotify extension must be loaded.","title":"Requirements"},{"location":"v2/hot-code-reload/#configuration","text":"The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'hot-code-reload' => [ // Set to true to enable hot code reload; the default is false. 'enable' => true, // Time in milliseconds between checks to changes in files. 'interval' => 500, ], ], ];","title":"Configuration"},{"location":"v2/hot-code-reload/#logging","text":"When a file is reloaded, a notice line will be logged with the message Reloading due to file change: {path} . The logger used to log these lines is the same used for access logging, which is described in the logging section of this documentation.","title":"Logging"},{"location":"v2/hot-code-reload/#limitations","text":"Only files included by PHP after onWorkerStart will be reloaded. This means that Swoole will not reload any of the following: New routes New pipeline middleware The Application instance, or any delegators used to modify it . The Swoole HTTP server itself. This limitation exists because the hot code reload features use the Swoole\\Server::reload() method to notify Swoole to reload PHP files (see the Swoole reload() documentation for more details ).","title":"Limitations"},{"location":"v2/how-it-works/","text":"How it works When you run an Expressive application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in zend-expressive-swoole is a runner that enables the execution of an Expressive application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this->swooleHttpServer->on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port); }); $this->swooleHttpServer->on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request->server['remote_addr'], $request->server['request_method'], $request->server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this->serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this->emitMarshalServerRequestException($emitter, $e); return; } $emitter->emit($this->handler->handle($psr7Request)); }); $this->swooleHttpServer->start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by zend-diactoros ) via the class Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Zend\\Expressive\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Expressive application using zend-expressive-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling. Performance The ZF developers performed a benchmark running the default zend-expressive-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Expressive with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"How it works"},{"location":"v2/how-it-works/#how-it-works","text":"When you run an Expressive application using Swoole, you will execute PHP from the command line interface, without using a web server . This sounds a bit strange in PHP, though it will be familiar to Node.js developers; the execution model under Swoole is similar to that technology. The HTTP server of Swoole is a PHP class that offers callbacks on a number of events, using the on(string $name, callable $action) method. The request handler implemented in zend-expressive-swoole is a runner that enables the execution of an Expressive application inside the on('request') event of Swoole\\Http\\Server . This runner is implemented in the Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner class. The basic implementation acts similar to the following: public function run() : void { $this->swooleHttpServer->on('start', function ($server) { printf(\"Swoole is running at %s:%s\\n\", $server->host, $server->port); }); $this->swooleHttpServer->on('request', function ($request, $response) { printf( \"%s - %s - %s %s\\n\", date('Y-m-d H:i:sO', time()), $request->server['remote_addr'], $request->server['request_method'], $request->server['request_uri'] ); $emitter = new SwooleEmitter($response); try { $psr7Request = ($this->serverRequestFactory)($request); } catch (Throwable $e) { // Error in generating the request $this->emitMarshalServerRequestException($emitter, $e); return; } $emitter->emit($this->handler->handle($psr7Request)); }); $this->swooleHttpServer->start(); } This package provides a bridge between Swoole\\Http\\Request ( $request ) and PSR-7 requests ( $psr7Request ; specifically as implemented by zend-diactoros ) via the class Zend\\Expressive\\Swoole\\ServerRequestSwooleFactory . It also provides a Swoole-specific emitter, Zend\\Expressive\\Swoole\\SwooleEmitter , that converts a PSR-7 response to a Swoole\\Http\\Response instance. When you run an Expressive application using zend-expressive-swoole, you will notice a bunch of PHP processes running. By default, Swoole executes 4 worker (or reactor ) processes and 1 master process, for a total of 5 PHP processes. The advantages of this architecture are many: it's very light and simple (just PHP processes running); it offers a service layer that is able to restart a worker automatically if it's not responding; and it allows executing multiple HTTP requests in parallel. The architecture is built for scaling.","title":"How it works"},{"location":"v2/how-it-works/#performance","text":"The ZF developers performed a benchmark running the default zend-expressive-skeleton application with Swoole 4.0.1, nginx 1.12.1, and Apache 2.4.27 (with mod_php) using PHP 7.2.7. The results demonstrated that Expressive with Swoole runs 4 to 5 times faster than nginx or Apache . This impressive result is primarily due to the shared memory approach of Swoole. Unlike traditional apache/php-fpm usage, the memory allocated in Swoole will not be freed after a request. This allows application configuration and artifacts (such as middleware and handlers) to persist between requests and processes. Under Swoole 4.1+, for even better performance, you can enable the option zend-expressive-swoole.enable_coroutine . When this is enabled, Swoole will run most I/O processes in coroutines. Doing so provides approximately 10 times faster performance than without coroutines, meaning a Swoole-based application can be 40 to 50 times faster than running under nginx or Apache. Performance improves with the number of workers (which are restricted by the amount of memory); as such, performance can increase from these numbers.","title":"Performance"},{"location":"v2/intro/","text":"Swoole Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel. Install swoole You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL . Install zend-expressive-swoole To install this package, use Composer : $ composer require zendframework/zend-expressive-swoole Swoole with Expressive zend-expressive-swoole enables an Expressive application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/zend-expressive-swoole start This command will execute Swoole on localhost via port 8080 . Other commands To get a list of all available commands, run the command without arguments: $$$$FENCED_CODE_BLOCK_5e3085c7d8c412.85515683 If you add the argument help before any command name, the tooling will provide you with more detailed information on that command. Expressive skeleton versions prior to 3.1.0 The above will work immediately after installing zend-expressive-swoole if you are using a version of zend-expressive-skeleton from 3.1.0 or later. For applications based on previous versions of the skeleton, you will need to create a configuration file such as config/autoload/zend-expressive-swoole.global.php or config/autoload/zend-expressive-swoole.local.php with the following contents: $$$$FENCED_CODE_BLOCK_5e3085c7d8c4e4.35187200 You can change the host address and/or host name as well as the port using a configuration file, as follows: // In config/autoload/swoole.local.php: return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'host' => '192.168.0.1', 'port' => 9501, ], ], ]; Providing additional Swoole configuration You can also configure the Swoole HTTP server using an options key to specify any accepted Swoole settings. For instance, the following configuration demonstrates enabling SSL: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ // Available in Swoole 4.1 and up; enables coroutine support // for most I/O operations: 'enable_coroutine' => true, // Configure Swoole HTTP Server: 'swoole-http-server' => [ 'host' => '192.168.0.1', 'port' => 9501, 'mode' => SWOOLE_BASE, // SWOOLE_BASE or SWOOLE_PROCESS; // SWOOLE_BASE is the default 'protocol' => SWOOLE_SOCK_TCP | SWOOLE_SSL, // SSL-enable the server 'options' => [ // Set the SSL certificate and key paths for SSL support: 'ssl_cert_file' => 'path/to/ssl.crt', 'ssl_key_file' => 'path/to/ssl.key', // Whether or not the HTTP server should use coroutines; // enabled by default, and generally should not be disabled: 'enable_coroutine' => true, // Overwrite the default location of the pid file; // required when you want to run multiple instances of your service in different ports: 'pid_file' => 'path/to/pid_file.pid', ], // Since 2.1.0: Set the process name prefix. // The master process will be named `{prefix}-master`, // worker processes will be named `{prefix}-worker-{id}`, // and task worker processes will be named `{prefix}-task-worker-{id}` 'process-name' => 'your-app', ], ], ]; SSL support By default, Swoole is not compiled with SSL support. To enable SSL in Swoole, it must be configured with the --enable-openssl or --with-openssl-dir=/path/to/openssl option. Serving static files We support serving static files. By default, we serve files with extensions in the whitelist defined in the constant Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Our static resource capabilities are fairly comprehensive; please see the chapter on static resources for full details on configuration.","title":"Introduction"},{"location":"v2/intro/#swoole","text":"Swoole is a PECL extension for developing asynchronous applications in PHP. It enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, or Websocket services without requiring in-depth knowledge about non-blocking I/O programming or the low-level Linux kernel.","title":"Swoole"},{"location":"v2/intro/#install-swoole","text":"You can install the Swoole extension on Linux or Mac environments using the following commands: $ pecl install swoole For more information on the extension, visit its package details on PECL .","title":"Install swoole"},{"location":"v2/intro/#install-zend-expressive-swoole","text":"To install this package, use Composer : $ composer require zendframework/zend-expressive-swoole","title":"Install zend-expressive-swoole"},{"location":"v2/intro/#swoole-with-expressive","text":"zend-expressive-swoole enables an Expressive application to be executed with the Swoole extension. This means you can run the application from the command line, without requiring a web server . You can run the application using the following command: $ ./vendor/bin/zend-expressive-swoole start This command will execute Swoole on localhost via port 8080 .","title":"Swoole with Expressive"},{"location":"v2/logging/","text":"Logging Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400). Access Logs Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Zend\\Expressive\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically. Formatting logs The Apache web server has long provided flexible and robust logging capabilities, and its formats are used across a variety of web servers and logging platforms. As such, we have chosen to use its formats for our standard implementation. However, we allow you to plug in your own system as needed. You can refer to the Apache mod_log_config documentation in order to understand the available placeholders available for format strings. Formatting is provided to the Psr3AccessLogDecorator via instances of the interface Zend\\Expressive\\Swoole\\Log\\AccessLogFormatterInterface : interface AccessLogFormatterInterface { public function format(AccessLogDataMap $map) : string; } AccessLogDataMap is a class used internally by the Psr3AccessLogDecorator in order to map Apache log placeholders to request/response values. Our default AccessLogFormatterInterface implementation, AccessLogFormatter , provides constants referencing the most common formats, but also allows you to use arbitrary log formats that use the standard Apache placeholders. The formats we include by default are: AccessLogFormatter::FORMAT_COMMON : Apache common log format: %h %l %u %t \"%r\" %>s %b AccessLogFormatter::FORMAT_COMMON_VHOST : Apache common log format + vhost: %v %h %l %u %t \"%r\" %>s %b AccessLogFormatter::FORMAT_COMBINED : Apache combined log format: %h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" AccessLogFormatter::FORMAT_REFERER : %{Referer}i -> %U AccessLogFormatter::FORMAT_AGENT : %{User-Agent}i AccessLogFormatter::FORMAT_VHOST : Alternative Apache vhost format: '%v %l %u %t \"%r\" %>s %b'; AccessLogFormatter::FORMAT_COMMON_DEBIAN : Debian variant of common log format: %h %l %u %t \u201c%r\u201d %>s %O ; AccessLogFormatter::FORMAT_COMBINED_DEBIAN : Debian variant of combined log format: %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\u201d ; AccessLogFormatter::FORMAT_VHOST_COMBINED_DEBIAN : Debian variant of combined log format + vhost: %v:%p %h %l %u %t \u201c%r\u201d %>s %O \u201c%{Referer}i\u201d \u201c%{User-Agent}i\" ; Configuring a logger You may subsitute your own logger implementation into the Swoole request handler runner. Manual usage If you are manually instantiating a Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner instance, you may provide it as the seventh argument to the constructor: use Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner; $runner = new SwooleRequestHandlerRunner( $application, $serverRequestFactory, $serverRequestErrorResponseGenerator, $pidManager, $serverFactory, $staticResourceHandler, $logger // <-- AccessLoggerInterface instance ); Container usage If you are using a PSR-11 container, the SwooleRequestHandlerRunnerFactory will retrieve a log instance using the Zend\\Expressive\\Swoole\\Log\\AccessLogInterface service. You have two options for substituting your own logger from there. First, if you already have a service which resolves to a Psr\\Log\\LoggerInterface instance, you can configure it by providing its name: 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'logger' => [ 'logger-name' => 'my_logger', // define the logger service name here ], ], ], If you don't want to manually provide the service name but you are okay with re-using your existing PSR-3 logger, the provided Zend\\Expressive\\Swoole\\Log\\AccessLogFactory will use the Psr\\Log\\LoggerInterface service to create a Psr3AccessLogDecorator instance. Since 2.4.0, the Zend\\Expressive\\Swoole\\Log\\AccessLogFactory will resolve the logger instance by using the Zend\\Expressive\\Swoole\\Log\\SwooleLogger service. If you were manually using this factory, you should register the service to the Zend\\Expressive\\Swoole\\Log\\SwooleLoggerFactory . This factory also allows you to specify a custom AccessLogFormatterInterface instance if you want. It will look up a service by the fully-qualified interface name, and use it if present. Otherwise, it creates an AccessLogFormatter instance for you. In both cases the factory will also look at the following configuration values: 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'logger' => [ 'format' => string, // one of the AccessLogFormatter::FORMAT_* // constants, or a custom format string 'use-hostname-lookups' => bool, // Set to true to enable hostname lookups ], ], ], Using Monolog as a PSR-3 logger When using Monolog with a StreamHandler , you must supply a file or a stream resource descriptor. We recommend using one of the following: php://stdout is a good choice, as this will generally write to the current console. php://stderr is also a good choice, as this will generally write to the current console, and allows you to filter based on that output stream. When using Docker , generally one of either /proc/1/fd/1 or /proc/1/fd/2 can be used, and are analogous to STDOUT and STDERR , respectively. We recommend using php://stdout and php://stderr instead, as these will be mapped to the correct locations by the language. ErrorLogHandler If you plan to write to STDERR , you might consider instead using the Monolog ErrorLogHandler , as this will use PHP's error_log() mechanism to write to the configured PHP error log. You can then either introspect that location, or configure the error_log php.ini setting to point to either /dev/stderr or, if on Docker, /proc/1/fd/2 . Additionally, we recommend using the PsrLogMessageProcessor with any Monolog handler to ensure that any templated parameters are expanded by the logger. As an example, the following is a factory that wires a StreamHandler to a Monolog\\Logger instance. use Psr\\Container\\ContainerInterface; use Psr\\Log\\LoggerInterface; use Monolog\\Handler\\StreamHandler; use Monolog\\Logger; use Monolog\\Processor\\PsrLogMessageProcessor; class LoggerFactory { public function __invoke(ContainerInterface $container) : LoggerInterface { $logger = new Logger('swoole-http-server'); $logger->pushHandler(new StreamHandler( 'php://stdout', Logger::INFO, $bubble = true, $expandNewLines = true )); $logger->pushProcessor(new PsrLogMessageProcessor()); return $logger; } } If you then wire this to the Psr\\Log\\LoggerInterface service, it will be used by Swoole for the purposes of access logs as well.","title":"Logging"},{"location":"v2/logging/#logging","text":"Web servers typically log request details, so that you can perform tasks such as analytics, identification of invalid requests, and more. Out-of-the-box, Swoole does not do this. As such, we provide these capabilities with this integration. We log a number of items: When the web server starts, indicating the host and port on which it is running. When workers start, including the working directory and worker ID. When the web server stops. When the web server reloads workers. Each request (more on this below) By default, logging is performed to STDOUT, using an internal logger. However, you can use any PSR-3 compliant logger to log application details. We emit logs detailing server operations using the priority Psr\\Log\\LogLevel::NOTICE (unless detailing an error, such as inability to reload)), while Psr\\Log\\LogLevel::INFO and Psr\\Log\\LogLevel::ERROR are used to log requests (errors are used for response statuses greater than or equal to 400).","title":"Logging"},{"location":"v2/logging/#access-logs","text":"Technically, the SwooleRequestHandlerRunner doesn't use PSR-3 loggers directly, but, rather, instances of Zend\\Expressive\\Swoole\\Log\\AccessLogInterface . This package-specific interface extends the PSR-3 interface to add two methods: use Psr\\Http\\Message\\ResponseInterface; use Psr\\Log\\LoggerInterface; use Swoole\\Http\\Request; use Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse; interface AccessLogInterface extends LoggerInterface { public function logAccessForStaticResource( Request $request, StaticResourceResponse $response ) : void; public function logAccessForPsr7Resource( Request $request, ResponseInterface $response ) : void; } To allow usage of a standard PSR-3 logger, we also provide a decorator, Zend\\Expressive\\Swoole\\Log\\Psr3AccessLogDecorator , which decorates the PSR-3 logger and provides a standard implementation for the two methods listed above. If you have defined a PSR-3 LoggerInterface service in your application, it will be used automatically.","title":"Access Logs"},{"location":"v2/logging/#configuring-a-logger","text":"You may subsitute your own logger implementation into the Swoole request handler runner.","title":"Configuring a logger"},{"location":"v2/migration/","text":"Migration This document covers changes between version 1 and version 2, and how you may update your code to adapt to them. Controlling the server In version 1, you would execute the web server via the entry script, e.g.: $ php public/index.php start With version 2, we ship the command line tools for controlling your server via the binary zend-expressive-swoole : # Start the server: $ ./vendor/bin/zend-expressive-swoole start -d # Reload the server: $ ./vendor/bin/zend-expressive-swoole reload # Stop the server: $ ./vendor/bin/zend-expressive-swoole stop While you can still call php public/index.php , you cannot daemonize the server using that command, nor reload or stop it (other than using Ctrl-C ). You will need to change any deployment commands you currently use to consume the new command line tooling. Coroutine support In version 1, to enable Swoole's coroutine support, you were expected to pass a boolean true value to the zend-expressive-swoole.swoole-http-server.options.enable_coroutine flag. That flag now controls specifically the HTTP server coroutine support, and defaults to true . To set system-wide coroutine support, toggle the zend-expressive-swoole.enable_coroutine flag, which defaults to boolean false: return [ 'zend-expressive-swoole' => [ 'enable_coroutine' => false, // system-wide support 'swoole-http-server' => [ 'options' => [ 'enable_coroutine' => true, // HTTP server coroutine support ], ], ] ]; ServerFactory Version 2 refactors the architecture slightly to allow providing the HTTP server as a service, which allows us to enable async task workers . The primary changes to enable this are: Zend\\Expressive\\Swoole\\ServerFactory and its associated service was removed. Zend\\Expressive\\Swoole\\ServerFactoryFactory was removed. Zend\\Expressive\\Swoole\\HttpServerFactory was created. The service Swoole\\Http\\Server was added, pointing to Zend\\Expressive\\Swoole\\HttpServerFactory . The constructor for Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner was modified. Previously, the fifth argument was typehinted against the former ServerFactory ; it now typehints against Swoole\\Http\\Server . The factory for this class was modified to pass the correct service. These changes should only affect users who were providing service substitutions or extending the affected classes.","title":"Migration"},{"location":"v2/migration/#migration","text":"This document covers changes between version 1 and version 2, and how you may update your code to adapt to them.","title":"Migration"},{"location":"v2/migration/#controlling-the-server","text":"In version 1, you would execute the web server via the entry script, e.g.: $ php public/index.php start With version 2, we ship the command line tools for controlling your server via the binary zend-expressive-swoole : # Start the server: $ ./vendor/bin/zend-expressive-swoole start -d # Reload the server: $ ./vendor/bin/zend-expressive-swoole reload # Stop the server: $ ./vendor/bin/zend-expressive-swoole stop While you can still call php public/index.php , you cannot daemonize the server using that command, nor reload or stop it (other than using Ctrl-C ). You will need to change any deployment commands you currently use to consume the new command line tooling.","title":"Controlling the server"},{"location":"v2/migration/#coroutine-support","text":"In version 1, to enable Swoole's coroutine support, you were expected to pass a boolean true value to the zend-expressive-swoole.swoole-http-server.options.enable_coroutine flag. That flag now controls specifically the HTTP server coroutine support, and defaults to true . To set system-wide coroutine support, toggle the zend-expressive-swoole.enable_coroutine flag, which defaults to boolean false: return [ 'zend-expressive-swoole' => [ 'enable_coroutine' => false, // system-wide support 'swoole-http-server' => [ 'options' => [ 'enable_coroutine' => true, // HTTP server coroutine support ], ], ] ];","title":"Coroutine support"},{"location":"v2/migration/#serverfactory","text":"Version 2 refactors the architecture slightly to allow providing the HTTP server as a service, which allows us to enable async task workers . The primary changes to enable this are: Zend\\Expressive\\Swoole\\ServerFactory and its associated service was removed. Zend\\Expressive\\Swoole\\ServerFactoryFactory was removed. Zend\\Expressive\\Swoole\\HttpServerFactory was created. The service Swoole\\Http\\Server was added, pointing to Zend\\Expressive\\Swoole\\HttpServerFactory . The constructor for Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner was modified. Previously, the fifth argument was typehinted against the former ServerFactory ; it now typehints against Swoole\\Http\\Server . The factory for this class was modified to pass the correct service. These changes should only affect users who were providing service substitutions or extending the affected classes.","title":"ServerFactory"},{"location":"v2/static-resources/","text":"Static Resources One feature of a web server is the ability to serve static files from your filesystem. zend-expressive-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Zend\\Expressive\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it. Disabling static resources Since 2.1.0 If you want to disable serving of static resources, you can do so in two ways. If you have a custom factory for the SwooleRequestHandlerRunner , or are instantiating it manually, pass a null value for the sixth argument of its constructor. As an example, within a factory: $$$$FENCED_CODE_BLOCK_5e3085c7d87054.31812887 If you are using the default factory provided ( Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunnerFactory ), you can also disable the functionality via configuration. To do this, set the zend-expressive-swoole.swoole-http-server.static-files.enable flag to boolean false : $$$$FENCED_CODE_BLOCK_5e3085c7d87207.02092007 Middleware The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers). Providing your own middleware If you want to disable middleware, or to provide an alternate list of middleware (including your own!), you will need to provide an alternate StaticResourceHandler factory. In most cases, you can extend StaticResourceHandlerFactory and override the configureMiddleware(array $config) : array method to do so. Be sure to remember to add a dependencies setting mapping the StaticResourceHandlerInterface service to your new factory when done! Configuration We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' => true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' => '/path/to/static/files/to/serve', // Extension => content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' => [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' => 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' => 'weak|strong', // gzip options 'gzip' => [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' => 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' => [ 'regex' => [ 'cache-control' => [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' => bool, // Emit a Last-Modified header? 'etag' => bool, // Emit an ETag header? ], ], ], ], ], ]; Security warning Never add php as an allowed static file extension, as doing so could expose the source code of your PHP application! Document root If no document_root configuration is present, the default is to use getcwd() . '/public' . If either the configured or default document root does not exist, we raise an exception. Default extension/content-types By default, we serve files with extensions in the whitelist defined in the constant Zend\\Expressive\\Swoole\\StaticResourceHandler\\ContentTypeFilterMiddleware::DEFAULT_STATIC_EXTS , which is derived from a list of common web MIME types maintained by Mozilla . Configuration Example The example which follows provides the following options: Sets the document root to /var/www/htdocs . Adds a custom extension / content-type map. Provides a clearstatcache interval of 2 hours. Selects the \"strong\" ETag algorithm. Indicates a gzip compression level of 3. Sets Cache-Control, Last-Modified, and ETag directives for JS, CSS, and image files. Sets Cache-Control directives for plain text files. // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ 'enable' => true, 'document-root' => '/var/www/htdocs', 'type-map' => [ 'css' => 'text/css', 'gif' => 'image/gif', 'ico' => 'image/x-icon', 'jpg' => 'image/jpg', 'jpeg' => 'image/jpg', 'js' => 'application/javascript', 'png' => 'image/png', 'svg' => 'image/svg+xml', 'txt' => 'text/plain', ], 'clearstatcache-interval' => 7200, 'etag-type' => 'strong', 'gzip' => [ 'level' => 3, ], 'directives' => [ '/\\.(css|gif|ico|jpg|jpeg|png|svg|js)$/' => [ 'cache-control' => [ 'public', 'no-transform', ], 'last-modified' => true, 'etag' => true, ], '/\\.txt$/' => [ 'cache-control' => [ 'public', 'no-cache', ], ], ], ], ], ], ]; Writing Middleware Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() . Providing an alternative mechanism for sending response content In some cases, you may want to alter how the Swoole\\Http\\Response receives the body content. By default, we use Swoole\\Http\\Response::sendfile() . However, this may not work well when performing tasks such as compression, appending a watermark, etc. As an example, the GzipMiddleware adds a compression filter to a filehandle representing the file to send, and then calls Swoole\\Http\\Response::write() in a loop until all content is sent. To perform work like this, you can call the StaticResourceResponse::setResponseContentCallback() method as detailed in the section above within your middleware. Alternative static resource handlers As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Zend\\Expressive\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Static Resources"},{"location":"v2/static-resources/#static-resources","text":"One feature of a web server is the ability to serve static files from your filesystem. zend-expressive-swoole provides that capability as well. To enable this, the package provides an alternate RequestHandlerRunner implementation via the class Zend\\Expressive\\Swoole\\SwooleRequestHandlerRunner that performs two duties: If a static resource is matched, it serves that. Otherwise, it passes off handling to the composed application pipeline. Internally, the SwooleRequestHandlerRunner composes another class, a Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface instance. This instance is passed the Swoole request and response, and returns a value indicating whether or not it was able to identify and serve a matching static resource. Our default implementation, Zend\\Expressive\\Swoole\\StaticResourceHandler , provides an approach that checks an incoming request path against a list of known extensions, and a configured document root. If the extension matches, it then checks to see if the file exists in the document root. If it does, it will serve it.","title":"Static Resources"},{"location":"v2/static-resources/#middleware","text":"The StaticResourceHandler implementation performs its work by composing a queue of middleware to execute when attempting to serve a matched file. Using this approach, we are able to provide a configurable set of capabilities for serving static resources. What we currently provide is as follows: CacheControlMiddleware will set a Cache-Control header based on configuration you provide it. Configuration uses a combination of regular expressions to match against the path, with the Cache-Control directive to use when the match occurs. ClearStatCacheMiddleware will, if configured to do so, call clearstatcache() either on every request, or at specific intervals. This is useful if you anticipate filesystem changes in your document root. ContentTypeFilterMiddleware checks the incoming filename against a map of known extensions and their associated Content-Type values. If it cannot match the file, it returns a value indicating no match was found so that the application can continue processing the request. Otherwise, it provides the Content-Type for the associated response. This middleware is generally best used as the outermost layer, to ensure no other middleware executes in the case that the file cannot be matched. ETagMiddleware will set an ETag header using either a strong or weak algorithm, and only on files matching given regular expressions. If the ETag header value matches either an If-Match or If-None-Match request header, it will provide a response status of 304 and disable sending content. GzipMiddleware detects the Accept-Encoding request header and, if present, and the compression level provided to the instance allows, it will compress the returned response content using either gzip or deflate compression as requested. HeadMiddleware will force an empty response. (The status and headers may be set by other middleware.) LastModifiedMiddleware will set a Last-Modified header using the filemtime() value of the requested resource. If the header value is later than an If-Modified-Since request header, it will provide a response status of 304 and disable sending content. MethodNotAllowedMiddleware will set the response status to 405 , and set an Allow header indicating the allowed methods when an unsupported request method is provided. OptionsMiddleware will force an empty response with an Allow header set to the allowed methods. (Other headers may also be present!) By default, these are registered in the following order, contingent on configuration being provided: ContentTypeFilterMiddleware MethodNotAllowedMiddleware OptionsMiddleware HeadMiddleware GzipMiddleware ClearStatCacheMiddleware CacheControlMiddleware LastModifiedMiddleware ETagMiddleware This approach ensures that the most expensive operations are never called unless other conditions are met (e.g., if the HTTP request method is not allowed, there's no need to calculate the Last-Modified or ETag headers); it also ensures that all possible headers are provided whenever possible (e.g., a HEAD request should also expose Cache-Control , Last-Modified , and ETag headers).","title":"Middleware"},{"location":"v2/static-resources/#configuration","text":"We provide a factory for the StaticResourceHandler that uses a configuration-driven approach in order to: Set the document root. Set the map of allowed extensions to content-types. Configure and provide middleware. The following demonstrates all currently available configuration options: // config/autoload/swoole.local.php return [ 'zend-expressive-swoole' => [ 'swoole-http-server' => [ 'static-files' => [ // Since 2.1.0: Set to false to disable any serving of static // files; all other configuration will then be ignored. 'enable' => true, // Document root; defaults to \"getcwd() . '/public'\" 'document-root' => '/path/to/static/files/to/serve', // Extension => content-type map. // Keys are the extensions to map (minus any leading `.`), // values are the MIME type to use when serving them. // A default list exists if none is provided. 'type-map' => [], // How often a worker should clear the filesystem stat cache. // If not provided, it will never clear it. The value should be // an integer indicating the number of seconds between clear // operations. 0 or negative values will clear on every request. 'clearstatcache-interval' => 3600, // Which ETag algorithm to use. // Must be one of \"weak\" or \"strong\"; the default, when none is // provided, is \"weak\". 'etag-type' => 'weak|strong', // gzip options 'gzip' => [ // Compression level to use. // Should be an integer between 1 and 9; values less than 1 // disable compression. 'level' => 4, ], // Rules governing which server-side caching headers are emitted. // Each key must be a valid regular expression, and should match // typically only file extensions, but potentially full paths. // When a static resource matches, all associated rules will apply. 'directives' => [ 'regex' => [ 'cache-control' => [ // one or more valid Cache-Control directives: // - must-revalidate // - no-cache // - no-store // - no-transform // - public // - private // - max-age=\\d+ ], 'last-modified' => bool, // Emit a Last-Modified header? 'etag' => bool, // Emit an ETag header? ], ], ], ], ], ];","title":"Configuration"},{"location":"v2/static-resources/#writing-middleware","text":"Static resource middleware must implement Zend\\Expressive\\Swoole\\StaticResourceHandler\\MiddlewareInterface , which defines the following: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; interface MiddlewareInterface { /** * @param string $filename The discovered filename being returned. * @param callable $next has the signature: * function (Request $request, string $filename) : StaticResourceResponse */ public function __invoke( Request $request, string $filename, callable $next ) : StaticResourceResponse; } The $next argument has the following signature: namespace Zend\\Expressive\\Swoole\\StaticResourceHandler; use Swoole\\Http\\Request; public function __invoke( Request $request, string $filename ) : StaticResourceResponse; Typically, middleware will look something like this: $response = $next($request, $filename); // if some request condition does not match: // return $response; // Otherwise, manipulate the returned $response instance and then return it. Middleware either produces or manipulates a Zend\\Expressive\\Swoole\\StaticResourceHandler\\StaticResourceResponse instance. That class looks like the following: class StaticResourceResponse { /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function __construct( int $status = 200, array $headers = [], bool $sendContent = true, callable $responseContentCallback = null ); public function addHeader(string $name, string $value) : void; public function disableContent() : void; /** * Call this method to indicate that the request cannot be served as a * static resource. The request runner will then proceed to execute * the associated application in order to generate the response. */ public function markAsFailure() : void; /** * @param callable $responseContentCallback Callback to use when emitting * the response body content via Swoole. Must have the signature: * function (SwooleHttpResponse $response, string $filename) : void */ public function setResponseContentCallback(callable $callback) : void; /** * Use this within a response content callback to set the associated * Content-Length of the generated response. Loggers can then query * for this information in order to provide that information in the logs. */ public function setContentLength(int $length) : void; public function setStatus(int $status) : void; } Most middleware will conditionally set the status, one or more headers, and potentially disable returning the response body (via disableContent() ). Middleware that restricts access or filters out specific files will also use markAsFailure() .","title":"Writing Middleware"},{"location":"v2/static-resources/#alternative-static-resource-handlers","text":"As noted at the beginning of this chapter, the SwooleRequestHandlerRunner composes a StaticResourceHandlerInterface instance in order to determine if a resource was matched by the request, and then to serve it. If you want to provide an alternative mechanism for doing so (e.g., to serve files out of a caching server), you will need to implement Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface : declare(strict_types=1); namespace Zend\\Expressive\\Swoole; use Swoole\\Http\\Request as SwooleHttpRequest; use Swoole\\Http\\Response as SwooleHttpResponse; interface StaticResourceHandlerInterface { /** * Attempt to process a static resource based on the current request. * * If the resource cannot be processed, the method should return null. * Otherwise, it should return the StaticResourceResponse that was used * to send the Swoole response instance. The runner can then query this * for content length and status. */ public function processStaticResource( SwooleHttpRequest $request, SwooleHttpResponse $response ) : ?StaticResourceHandler\\StaticResourceResponse; } Once implemented, map the service Zend\\Expressive\\Swoole\\StaticResourceHandlerInterface to a factory that returns your custom implementation within your dependencies configuration.","title":"Alternative static resource handlers"},{"location":"v2/table/","text":"Using Swoole Tables in Your Application Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor. Initialize the Table Within the Constructor You must call your table's create() method, and this must be done prior to initializing any worker processes; if you fail to do so, your table will not work. We recommend doing this in your table class's constructor. Creating a Table As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this->column('x', self::TYPE_FLOAT); $this->column('y', self::TYPE_FLOAT); $this->column('z', self::TYPE_FLOAT); $this->create(); } } Creating Your Table Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' => [ // ... Vector3dTable::class => new Vector3dTable(), ], ]; } Using the Table Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container->get(Vector3dTable::class) (to use our previous example). Troubleshooting If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table->create() in your custom table's constructor.","title":"Using Swoole Tables"},{"location":"v2/table/#using-swoole-tables-in-your-application","text":"Sometimes, you need to share structured data between your message workers and have data outlive your request cycle. Swoole Tables are designed to do this for you. They require no additional work and are automatically synchronized. For reasons that will become clear presently, we recommend creating memory tables by extending the Swoole\\Table class, defining the appropriate columns and table size inside of the constructor.","title":"Using Swoole Tables in Your Application"},{"location":"v2/table/#creating-a-table","text":"As an example of a custom table class, consider the following example, which defines a table that can contain up to 1024 rows, each with three columns accepting float values to define a 3-dimensional vector, e.g. src/App/Table/Vector3dTable.php : namespace App\\Table; use Swoole\\Table; final class Vector3dTable extends Table { public function __construct() { parent::__construct(1024); // Table size $this->column('x', self::TYPE_FLOAT); $this->column('y', self::TYPE_FLOAT); $this->column('z', self::TYPE_FLOAT); $this->create(); } }","title":"Creating a Table"},{"location":"v2/table/#creating-your-table","text":"Now that we have defined a table class, we need to wire the application to use it. Tables must be created inside of your main process, in order to ensure each worker process has access to them. Since we define the columns and table size in the constructor, we can accomplish this by mapping the service name to a concrete instance, using the services dependency configuration key in a config provider class, e.g. src/App/ConfigProvider.php : private function getDependencies() : array { return [ 'services' => [ // ... Vector3dTable::class => new Vector3dTable(), ], ]; }","title":"Creating Your Table"},{"location":"v2/table/#using-the-table","text":"Classes that will push values to or pull values from the table can compose an instance of your custom class just as they normally would. Factories will then fetch the instance using $container->get(Vector3dTable::class) (to use our previous example).","title":"Using the Table"},{"location":"v2/table/#troubleshooting","text":"If you receive the message PHP Fatal error: Swoole\\Table::offsetSet(): the table object does not exist , then chances are you are not calling $table->create() in your custom table's constructor.","title":"Troubleshooting"}]}